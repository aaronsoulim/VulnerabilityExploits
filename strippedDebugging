With the goal of overwriting the Saved Insctruction Pointer via it's address on the stack:

1 starti [args] (in case of debugging to overwrite <seip>, args can be a dummy input, like "AAAA")
2 info files (<entry point> ~ <.text>)
3 break *<entry point>
4 c; disas $eip, +100 (continue to breakpoint disassemble at the instruction pointer, showing 100 lines)
5 break *<main> (<main> found in %eax register before main's call)
6 c; info frame (seip value and address, overwriting with shellcode address)
7 layout asm (assembly view, locate last function before ret instruction, ensuring input stored on stack)
8 ^+X+A; break *<puts@plt>
9 x/100xw $esp (displays 100 words {4-bytes} at top of stack in hexcode, distance between beginning of buffer {dummy input 0x41414141} and <seip> can be seen,
               (adjust malicious input accordingly)
